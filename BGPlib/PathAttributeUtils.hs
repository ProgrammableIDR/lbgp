{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE FlexibleInstances #-}
{-#LANGUAGE OverloadedStrings #-}
module BGPlib.PathAttributeUtils where
import Data.Word
import Data.IP
import Data.Maybe(fromJust,fromMaybe)
import Data.List(delete)

import BGPlib.PathAttributes

prePendAS :: ASNumber a => a -> [PathAttribute] -> [PathAttribute]
prePendAS asn = updatePathAttribute TypeCodePathAttributeASPath (asPrePend' asn) where
    asPrePend' asn ( PathAttributeASPath p) = PathAttributeASPath (asPrePend asn p)

getASPathLength :: [PathAttribute] -> Int
getASPathLength pas = maybe
                      0
                      (\(PathAttributeASPath asPath) -> asPathLength asPath)
                      (getPathAttribute TypeCodePathAttributeASPath pas)

-- normaliseASPath:  eliminate as4 path by replacing the original as2 path with the contens of the as4 path
-- should be a lossless conversion
-- the reverse would be needed if talking to an as2 only peer...
normaliseASPath pas = let toASPath4' (PathAttributeASPath p) = PathAttributeASPath (toASPath4 p)
                          pas' = updatePathAttribute TypeCodePathAttributeASPath toASPath4' pas in
    maybe pas'
          (\(PathAttributeAS4Path path) -> deletePathAttributeType TypeCodePathAttributeAS4Path $ insertPathAttribute (PathAttributeASPath (toASPath4 path)) pas)
          (getPathAttribute TypeCodePathAttributeAS4Path pas)

getAS2Path = fromJust . getPathAttribute TypeCodePathAttributeASPath
getAS4Path = fromJust . getPathAttribute TypeCodePathAttributeAS4Path

getASPathAttribute pax = fromMaybe (getAS2Path pax) (getPathAttribute TypeCodePathAttributeAS4Path pax)

getASPath :: [PathAttribute] -> ASPath
getASPath = unwrapASPath . getASPathAttribute where
    unwrapASPath (PathAttributeASPath asPath) = asPath
    unwrapASPath (PathAttributeAS4Path asPath) = asPath

getASPathContent :: [PathAttribute] -> [ASSegment Word32]
getASPathContent = unwrapSegments . toASPath4 . getASPath where
    unwrapSegments (ASPath4 segments) = segments
-- getASPathContent (PathAttributeASPath (ASPath4 segments)) = segments
-- getASPathContent (PathAttributeASPath (ASPath2 segments)) = map toASPath4 segments

getASPathSegmentCount = length . getASPathContent
getASPathOrigin = getLastASN . last . getASPathContent

-- getLastASN :: ASSegment Word32 -> Word32
getLastASN (ASSequence ax) = last ax
getLastASN (ASSet ax) = head ax

setLocalPref :: Word32 -> [PathAttribute] -> [PathAttribute]
setLocalPref = insertPathAttribute . PathAttributeLocalPref

getLocalPref :: [PathAttribute] -> Word32
getLocalPref pas = maybe 0 (\(PathAttributeLocalPref x) -> x) (getPathAttribute TypeCodePathAttributeLocalPref pas)

setMED :: Word32 -> [PathAttribute] -> [PathAttribute]
setMED = insertPathAttribute . PathAttributeMultiExitDisc

getMED :: [PathAttribute] -> Word32
getMED pas = maybe 0 (\(PathAttributeMultiExitDisc x) -> x) (getPathAttribute TypeCodePathAttributeMultiExitDisc pas)

setOrigin :: Word8 -> [PathAttribute] -> [PathAttribute]
setOrigin = insertPathAttribute . PathAttributeOrigin

getOrigin :: [PathAttribute] -> Word8
getOrigin pas = maybe 0 (\(PathAttributeOrigin x) -> x ) (getPathAttribute TypeCodePathAttributeOrigin pas)

setNextHop :: IPv4 -> [PathAttribute] -> [PathAttribute]
setNextHop = insertPathAttribute . PathAttributeNextHop

getNextHop :: [PathAttribute] -> IPv4
getNextHop pas = maybe "127.0.0.127" (\(PathAttributeNextHop x) -> x ) (getPathAttribute TypeCodePathAttributeNextHop pas)

checkForRequiredPathAttributes :: [PathAttribute] -> Bool
checkForRequiredPathAttributes pas = included requiredPathAttributes (map identify pas)


-- there may be a standard way to express this - the requirement is that all elements of the list requiredPathAttributes
-- are in the list generated by '(map identify pas)'
-- note that this is a test for presence not equality
-- i think Data.list has something.....

included [] _ = True
included ax [] | not (null ax) = False
included ax (b:bx) = included (delete b ax) bx
